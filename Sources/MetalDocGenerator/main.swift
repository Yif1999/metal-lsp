import Foundation
import MetalCore

/// Build-time tool to generate Metal documentation Swift code from spec
func main() {
  guard CommandLine.arguments.count >= 3 else {
    print("Usage: metal-doc-generator <spec.md> <output.swift>")
    exit(1)
  }

  let specPath = CommandLine.arguments[1]
  let outputPath = CommandLine.arguments[2]

  print("Parsing Metal spec: \(specPath)")

  do {
    let parser = try MetalSpecParser(specPath: specPath)
    var entries: [DocumentationEntry] = []

    // Parse all common symbols
    let symbols = collectSymbols(from: specPath)

    print("Found \(symbols.count) symbols to process")
    var foundCount = 0

    for (index, symbol) in symbols.enumerated() {
      if index % 10 == 0 {
        print("Processing: \(index)/\(symbols.count)...")
      }

      if let doc = parser.findDocumentation(for: symbol) {
        let entry = DocumentationEntry(
          symbol: doc.name,
          signature: doc.signature,
          description: doc.description,
          kind: kindToString(doc.kind),
          category: determineCategory(symbol: symbol)
        )
        entries.append(entry)
        foundCount += 1
      }
    }

    print("Found documentation for \(foundCount)/\(symbols.count) symbols")

    // Generate Swift code
    let swiftCode = generateSwiftCode(entries: entries)
    try swiftCode.write(to: URL(fileURLWithPath: outputPath), atomically: true, encoding: .utf8)

    let sizeKB = Double(swiftCode.utf8.count) / 1024.0
    print("Generated Swift code: \(outputPath) (\(String(format: "%.1f", sizeKB)) KB)")
    print("Generated \(entries.count) builtin entries")
  } catch {
    print("Error: \(error)")
    exit(1)
  }
}

func generateSwiftCode(entries: [DocumentationEntry]) -> String {
  var code = """
  // Auto-generated from Metal Shading Language Specification
  // DO NOT EDIT MANUALLY
  // Generated by MetalDocGenerator

  import Foundation

  extension MetalDocumentation {
    /// Built-in Metal documentation entries compiled into the binary
    static let builtinEntries: [DocumentationEntry] = [

  """

  // Sort entries for consistent output
  let sortedEntries = entries.sorted { $0.symbol < $1.symbol }

  for (index, entry) in sortedEntries.enumerated() {
    let escapedSignature = escapeSwiftString(entry.signature)
    let escapedDescription = escapeSwiftString(entry.description)
    let escapedCategory = entry.category.map { escapeSwiftString($0) } ?? "nil"

    code += "      DocumentationEntry(\n"
    code += "        symbol: \"\(escapeSwiftString(entry.symbol))\",\n"
    code += "        signature: \"\(escapedSignature)\",\n"
    code += "        description: \"\(escapedDescription)\",\n"
    code += "        kind: \"\(escapeSwiftString(entry.kind))\",\n"
    code += "        category: \(escapedCategory == "nil" ? "nil" : "\"\(escapedCategory)\"")\n"
    code += "      )"

    if index < sortedEntries.count - 1 {
      code += ","
    }
    code += "\n"
  }

  code += """
    ]
  }

  """

  return code
}

func escapeSwiftString(_ str: String) -> String {
  return str
    .replacingOccurrences(of: "\\", with: "\\\\")
    .replacingOccurrences(of: "\"", with: "\\\"")
    .replacingOccurrences(of: "\n", with: "\\n")
    .replacingOccurrences(of: "\r", with: "\\r")
    .replacingOccurrences(of: "\t", with: "\\t")
}

func kindToString(_ kind: SymbolDocumentation.SymbolKind) -> String {
  switch kind {
  case .function: return "function"
  case .type: return "type"
  case .keyword: return "keyword"
  }
}

func determineCategory(symbol: String) -> String {
  // Categorize symbols for better organization
  if symbol.hasSuffix("2") || symbol.hasSuffix("3") || symbol.hasSuffix("4") {
    return "Vector Types"
  } else if symbol.contains("x") && (symbol.contains("2") || symbol.contains("3") || symbol.contains("4")) {
    return "Matrix Types"
  } else if symbol.starts(with: "texture") || symbol.starts(with: "depth") {
    return "Texture Types"
  } else if ["bool", "char", "uchar", "short", "ushort", "int", "uint", "long", "ulong", "half", "float", "bfloat"].contains(symbol) {
    return "Scalar Types"
  } else if ["kernel", "vertex", "fragment", "compute"].contains(symbol) {
    return "Function Qualifiers"
  } else if ["device", "constant", "thread", "threadgroup"].contains(symbol) {
    return "Address Space Qualifiers"
  } else if ["sin", "cos", "tan", "asin", "acos", "atan", "atan2", "sinh", "cosh", "tanh"].contains(symbol) {
    return "Trigonometric Functions"
  } else if ["exp", "exp2", "log", "log2", "pow", "sqrt", "rsqrt"].contains(symbol) {
    return "Exponential Functions"
  } else if ["abs", "ceil", "floor", "round", "trunc", "fract", "fmod", "modf", "fma"].contains(symbol) {
    return "Common Functions"
  } else if ["dot", "cross", "distance", "length", "normalize", "faceforward", "reflect", "refract"].contains(symbol) {
    return "Geometric Functions"
  } else if ["min", "max", "clamp", "mix", "step", "smoothstep", "sign", "saturate"].contains(symbol) {
    return "Common Functions"
  } else if symbol.contains("sample") || symbol.contains("read") || symbol.contains("write") {
    return "Texture Functions"
  } else {
    return "Other"
  }
}

func collectSymbols(from specPath: String) -> [String] {
  var symbols = Set<String>()

  // Scalar types
  let scalarTypes = ["bool", "char", "uchar", "short", "ushort", "int", "uint", "long", "ulong", "half", "float", "bfloat"]
  symbols.formUnion(scalarTypes)

  // Vector types
  for base in ["bool", "char", "uchar", "short", "ushort", "int", "uint", "long", "ulong", "half", "float"] {
    for dim in 2...4 {
      symbols.insert("\(base)\(dim)")
    }
  }

  // Packed vector types
  for base in ["char", "uchar", "short", "ushort", "int", "uint", "half", "float"] {
    for dim in 2...4 {
      symbols.insert("packed_\(base)\(dim)")
    }
  }

  // Matrix types
  for base in ["half", "float"] {
    for rows in 2...4 {
      for cols in 2...4 {
        symbols.insert("\(base)\(rows)x\(cols)")
      }
    }
  }

  // Texture types
  let textureTypes = [
    "texture1d", "texture1d_array",
    "texture2d", "texture2d_array", "texture2d_ms", "texture2d_ms_array",
    "texture3d",
    "texturecube", "texturecube_array",
    "texture_buffer",
    "depth2d", "depth2d_array", "depth2d_ms", "depth2d_ms_array",
    "depthcube", "depthcube_array"
  ]
  symbols.formUnion(textureTypes)

  // Sampler and other types
  symbols.formUnion(["sampler", "atomic_int", "atomic_uint"])

  // Address space qualifiers
  symbols.formUnion(["device", "constant", "thread", "threadgroup"])

  // Function qualifiers
  symbols.formUnion(["kernel", "vertex", "fragment", "compute"])

  // Common math functions
  let mathFunctions = [
    "abs", "acos", "acosh", "asin", "asinh", "atan", "atan2", "atanh",
    "ceil", "clamp", "cos", "cosh", "cross", "degrees",
    "distance", "dot", "exp", "exp2", "exp10", "fabs",
    "faceforward", "floor", "fma", "fmax", "fmin", "fmod",
    "fract", "frexp", "length", "log", "log2", "log10",
    "max", "max3", "min", "min3", "mix", "modf",
    "normalize", "pow", "powr", "radians", "reflect", "refract",
    "round", "rsqrt", "saturate", "sign", "sin", "sincos", "sinh",
    "smoothstep", "sqrt", "step", "tan", "tanh", "trunc"
  ]
  symbols.formUnion(mathFunctions)

  // Integer functions
  let integerFunctions = [
    "absdiff", "addsat", "clz", "ctz", "extract_bits", "hadd",
    "insert_bits", "mad24", "madhi", "madsat", "median3",
    "mulhi", "mul24", "popcount", "reverse_bits", "rhadd", "rotate", "subsat"
  ]
  symbols.formUnion(integerFunctions)

  // Relational functions
  let relationalFunctions = [
    "all", "any", "isequal", "isfinite", "isgreater", "isgreaterequal",
    "isinf", "isless", "islessequal", "islessgreater", "isnan", "isnormal",
    "isnotequal", "isordered", "isunordered", "select"
  ]
  symbols.formUnion(relationalFunctions)

  print("Total symbols to search: \(symbols.count)")
  return Array(symbols).sorted()
}

main()
